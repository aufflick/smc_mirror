// -*- mode: text; tab-width: 4; mode: auto-fill -*-
%{
/*
 * The contents of this file are subject to the Mozilla Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.mozilla.org/MPL/
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is State Machine Compiler (SMC).
 * 
 * The Initial Developer of the Original Code is Charles W. Rapp.
 * Portions created by Charles W. Rapp are
 * Copyright (C) 2000 Charles W. Rapp.
 * All Rights Reserved.
 * 
 * Contributor(s): 
 *
 * smcParser --
 *
 *  This state machine defines the  state machine language.
 *
 * RCS ID
 * $Id$
 *
 * CHANGE LOG
 * $Log$
 * Revision 1.4  2002/02/19 19:52:49  cwrapp
 * Changes in release 1.3.0:
 * Add the following features:
 * + 479555: Added subroutine/method calls as argument types.
 * + 508878: Added %import keyword.
 *
 * Revision 1.2  2001/12/14 20:10:37  cwrapp
 * Changes in release 1.1.0:
 * Add the following features:
 * + 486786: Added the %package keyword which specifies the
 *           Java package/C++ namespace/Tcl namespace
 *           the SMC-generated classes will be placed.
 * + 486471: The %class keyword accepts fully qualified
 *           class names.
 * + 491135: Add FSMContext methods getDebugStream and
 *           setDebugStream.
 * + 492165: Added -sync command line option which causes
 *           the transition methods to be synchronized
 *           (this option may only be used with -java).
 *
 * Revision 1.1  2001/12/03 14:14:03  cwrapp
 * Changes in release 1.0.2:
 * + Placed the class files in Smc.jar in the net.sf.smc package.
 * + Moved Java source files from smc/bin to net/sf/smc.
 * + Corrected a C++ generation bug wherein arguments were written
 *   to the .h file rather than the .cpp file.
 *
 * Revision 1.3  2001/06/16 19:52:43  cwrapp
 * Changes in release 1.0, beta 7:
 * Fixes the minor code generation bugs and introduces a new
 * example Java program (found at examples/Java/EX7). This
 * example program is also a Java applet and can be seen at
 * http://smc.sourceforge.net/SmcDemo.htm.
 *
 * Revision 1.2  2001/05/09 23:40:01  cwrapp
 * Changes in release 1.0, beta 6:
 * Fixes the four following bugs:
 * + 416011: SMC does not properly handle pop transitions which
 *       have no argument.
 * + 416013: SMC generated code does not throw a
 *       "Transition Undefined" exception as per Programmer's
 *       Manual.
 * + 416014: The initial state's Entry actions are not being
 *       executed.
 * + 416015: When a transition has both a guarded and an unguarded
 *       definition, the Exit actions are only called when the
 *       guard evaluates to true.
 * + 422795: SMC -tcl abnormally terminates.
 *
 * Revision 1.1.1.2  2001/03/26 14:41:46  cwrapp
 * Corrected Entry/Exit action semantics. Exit actions are now
 * executed only by simple transitions and pop transitions.
 * Entry actions are executed by simple transitions and push
 * transitions. Loopback transitions do not execute either Exit
 * actions or entry actions. See SMC Programmer's manual for
 * more information.
 *
 * Revision 1.1.1.1  2001/01/03 03:13:59  cwrapp
 *
 * ----------------------------------------------------------------------
 * SMC - The State Map Compiler
 * Version: 1.0, Beta 3
 *
 * SMC compiles state map descriptions into a target object oriented
 * language. Currently supported languages are: C++, Java and [incr Tcl].
 * SMC finite state machines have such features as:
 * + Entry/Exit actions for states.
 * + Transition guards
 * + Transition arguments
 * + Push and Pop transitions.
 * + Default transitions. 
 * ----------------------------------------------------------------------
 *
 * Revision 1.2  2000/09/01 15:32:18  charlesr
 * Changes for v. 1.0, Beta 2:
 *
 * + Removed order dependency on "%start", "%class" and "%header"
 *   appearance. These three tokens may now appear in any order but
 *   still must appear before the first map definition.
 *
 * + Modified SMC parser so that it will continue after finding an
 *   error. Also improved the error message quality.
 *
 * + Made error messages so emacs is able to parse them.
 *
 * Revision 1.1.1.1  2000/08/02 12:50:56  charlesr
 * Initial source import, SMC v. 1.0, Beta 1.
 *
 */
%}

%start ParserMap::Start
%class SmcParser
%package net.sf.smc
%import java.util.List

%map ParserMap
%%
Start
{
    // The statemap can start with an optional raw source code section or
    // go straight to the map definitions.
    SOURCE(token : SmcLexer.Token)
                    Start2              {addSource(token);
                                         setHeaderLine();}

    // The state map's start state and class name must be
    // specified before the map name.
    // The header file is optional since its name can be
    // deduced from the class name (maybe). The class name
    // and header file are ignored when generating Tcl code.
    START_STATE(token : SmcLexer.Token)
                    StateNameStart      {setHeaderLine();}
    CLASS_NAME(token : SmcLexer.Token)
                    push(NameMap::FQName)
                                        {setHeaderLine();
                                         setNameType(SmcLexer.CLASS_NAME);}
    HEADER_FILE(token : SmcLexer.Token)
                    HeaderFile          {setHeaderLine();}
    PACKAGE_NAME(token : SmcLexer.Token)
                    push(NameMap::FQName)
                                        {setNameType(SmcLexer.PACKAGE_NAME);}
    IMPORT(token : SmcLexer.Token)
				    push(NameMap::FQName)
										{setHeaderLine();
										 setNameType(SmcLexer.IMPORT);}

    // These transitions are issued when the FQName has been
    // parsed.
    FQNameDone(name : String)
                    Start2              {setClassName(name);}
    FQNameError     Start2              {}

    MAP_NAME(token : SmcLexer.Token)
                    MapName             {error("%map not preceded by %start or %class.", false);}

    Default         StartError          {error("Expecting \"%{ source %}\", %start, or %class.", false);}
}

// Remain in this start until a known good token is found.
StartError
{
    // Do error checks first.
    START_STATE(token : SmcLexer.Token) [isStartStateSet();]
                    nil                 {setHeaderLine();}

    CLASS_NAME(token : SmcLexer.Token) [isClassSet();]
                    nil                 {setHeaderLine();}

    HEADER_FILE(token : SmcLexer.Token) [isHeaderSet();]
                    nil                 {setHeaderLine();}

    PACKAGE_NAME(token : SmcLexer.Token) [isPackageSet();]
                    StartError          {}

    // Everything is OK.
    START_STATE(token : SmcLexer.Token)
                    StateNameStart      {setHeaderLine();}

    CLASS_NAME(token : SmcLexer.Token)
                    push(NameMap::FQName)
                                        {setHeaderLine();
                                         setNameType(SmcLexer.CLASS_NAME);}

    HEADER_FILE(token : SmcLexer.Token)
                    HeaderFile          {setHeaderLine();}

    PACKAGE_NAME(token : SmcLexer.Token)
                    push(NameMap::FQName)
                                        {setNameType(SmcLexer.PACKAGE_NAME);}

    IMPORT(token : SmcLexer.Token)
				    push(NameMap::FQName)
										{setHeaderLine();
										 setNameType(SmcLexer.IMPORT);}

    MAP_NAME(token : SmcLexer.Token)
                    MapName             {}

    // These transitions are issued when the FQName has been
    // parsed.
    FQNameDone(name : String)
                    Start2              {setClassName(name);}
    FQNameError     Start2              {}

    Default         nil                 {}
}

Start2
{
    // Do error checks first.
    START_STATE(token : SmcLexer.Token) [isStartStateSet();]
                    StartError          {warning("Start state already set - ignoring this %start.");
                                         setHeaderLine();}

    CLASS_NAME(token : SmcLexer.Token) [isClassSet();]
                    StartError          {warning("Class already set - ignoring this %class.");
                                         setHeaderLine();}

    HEADER_FILE(token : SmcLexer.Token) [isHeaderSet();]
                    StartError          {warning("Header already set - ignoring this %header.");
                                         setHeaderLine();}

    PACKAGE_NAME(token : SmcLexer.Token) [isPackageSet();]
                    StartError          {warning("Package already set - ignoring this %package.");
                                         setHeaderLine();}

    START_STATE(token : SmcLexer.Token)
                    StateNameStart      {setHeaderLine();}

    CLASS_NAME(token : SmcLexer.Token)
                    push(NameMap::FQName)
                                        {setHeaderLine();
                                         setNameType(SmcLexer.CLASS_NAME);}

    HEADER_FILE(token : SmcLexer.Token)
                    HeaderFile          {setHeaderLine();}

    PACKAGE_NAME(token : SmcLexer.Token)
                    push(NameMap::FQName)
                                        {setHeaderLine();
                                         setNameType(SmcLexer.PACKAGE_NAME);}

    IMPORT(token : SmcLexer.Token)
				    push(NameMap::FQName)
										{setHeaderLine();
										 setNameType(SmcLexer.IMPORT);}
    MAP_NAME(token : SmcLexer.Token)
                    MapName             {setHeaderLine();}

    // These transitions are issued when the FQName has been
    // parsed.
    FQNameDone(name : String)
                    Start2              {setClassName(name);}
    FQNameError     Start2              {}

    Default         nil                 {error("Expecting \"%start\", \"%class\", \"%header\", \"%package\" or \"%map\".", false);}
}

// The state name must be of the form "map::state".
StateNameStart
{
    WORD(token : SmcLexer.Token)
                    StateName1          {appendStartState(token);}

    Default         StartError          {error("Missing state after %start.", false);}
}

StateName1
{
    COLON(token : SmcLexer.Token)
                    StateName2          {appendStartState(token);}

    Default         StartError          {error("%start must use a fully qualified state name.", false);}
}

StateName2
{
    COLON(token : SmcLexer.Token)
                    StateName3          {appendStartState(token);}

    Default         StartError          {error("%start must use a fully qualified state name.", false);}
}

StateName3
{
    WORD(token : SmcLexer.Token)
                    Start2              {appendStartState(token);
                                         setStartState();}

    Default         StartError          {error("%start must use a fully qualified state name.", false);}
}

HeaderFile
{
    WORD(token : SmcLexer.Token)
                    Start2              {setHeader(token);}

    Default         Start2              {error("Missing header file after %header.", false);}
}

MapStart
{
    MAP_NAME(token : SmcLexer.Token)
                    MapName             {}

    Default         MapStartError       {error("Expecting %map.", false);}
}

MapStartError
{
    MAP_NAME(token : SmcLexer.Token)
                    MapName             {}

    Default         nil                 {}
}

MapName
{
    WORD(token : SmcLexer.Token) [isDuplicateMap(token);]
                    MapStates           {error("Duplicate map name.", false);
                                         createMap(token);}

    // The next word transition is the map's name.
    WORD(token : SmcLexer.Token)
                    MapStates           {createMap(token);}

    EOD(token : SmcLexer.Token)
                    States              {error("Name expected after \"%map\".", false);
                                         createMap(token);}
    Default         nil                 {error("Name expected after \"%map\".", false);}
}

MapStates
{
    // %% marks the start of the map states.
    EOD(token : SmcLexer.Token)
                    States              {}

    WORD(token : SmcLexer.Token)
                    StateStart          {error("Expecting %% after \"%map mapname\".", false);
                                         createState(token);}

    Default         MapStatesError      {error("Expecting %% after \"%map mapname\".", false);}
}

MapStatesError
{
    EOD(token : SmcLexer.Token)
                    States              {}

    MAP_NAME(token : SmcLexer.Token)
                    MapName             {addMap();}
    WORD(token : SmcLexer.Token)
                    StateStart          {createState(token);}

    Default         nil                 {}
}

States
{
    // The "%%" means we have reached the end of this map's definition.
    EOD(token : SmcLexer.Token)
                    MapStart            {addMap();}

    // A word is the next state's name.
    WORD(token : SmcLexer.Token) [isDuplicateState(token);]
                    StateStart          {error("Duplicate state name.", false);
                                         createState(token);}

    WORD(token : SmcLexer.Token)
                    StateStart          {createState(token);}

    // Error transitions.
    ENTRY(token : SmcLexer.Token)
                    EntryStart          {error("Expecting either a new state definition or end of map (%%).", false);
                                         createState(token);}

    EXIT(token : SmcLexer.Token)
                    ExitStart           {error("Expecting either a new state definition or end of map (%%).", false);
                                         createState(token);}

    LEFT_BRACE(token : SmcLexer.Token)
                    Transitions         {error("Expecting either a new state definition or end of map (%%).", false);
                                         createState(token);}
    MAP_NAME(token : SmcLexer.Token)
                    MapName             {error("Expecting \"%%\" before another \"%map\".", false);
                                         addMap();}

    Default         nil                 {error("Expecting either a new state definition or end of map (%%).", false);}
}

StateStart
{
    // Check for repeat errors.
    ENTRY(token : SmcLexer.Token) [isEntrySet();]
                    StateStartError     {warning("This state already has an entry action defined - ignoring this entry action.");}

    EXIT(token : SmcLexer.Token) [isExitSet();]
                    StateStartError     {warning("This state already has an exit action defined - ignoring this exit action.");}

    // This state has an entry actions.
    ENTRY(token : SmcLexer.Token)
                    EntryStart          {}

    // This state has an exit action.
    EXIT(token : SmcLexer.Token)
                    ExitStart           {}

    // The left brace marks the start of the transitions.
    LEFT_BRACE(token : SmcLexer.Token)
                    Transitions         {}

    Default         StateStartError     {error("After the state name is given, then either an entry action, exit action or '{' is expected.", false);}
}

StateStartError
{
    ENTRY(token : SmcLexer.Token) [isEntrySet();]
                    StateStartError     {}
    EXIT(token : SmcLexer.Token) [isExitSet();]
                    StateStartError     {}

    ENTRY(token : SmcLexer.Token)
                    EntryStart          {}

    EXIT(token : SmcLexer.Token)
                    ExitStart           {}

    LEFT_BRACE(token : SmcLexer.Token)
                    Transitions         {}

    Default     nil         {}
}

EntryStart
{
    LEFT_BRACE(token : SmcLexer.Token)
                    push(ActionMap::MultiStart)
                                        {}

    // One entry action has been found. Check for more.
    action_done     push(ActionMap::MultiStart)
                                        {addEntryAction();}

    // All actions have been found. Now go parse the
    // state's transitions.
    actions_done    StateStart          {}

    Default         StateStartError     {error("A '{' is expected after Entry.", false);}
}

ExitStart
{
    LEFT_BRACE(token : SmcLexer.Token)
                    push(ActionMap::MultiStart)
                                        {}

    // One exit action has been found. Check for others.
    action_done     push(ActionMap::MultiStart)
                                        {addExitAction();}

    // All exit actions have been found. Now parse the rest
    // of the state.
    actions_done    StateStart          {}

    Default         StateStartError     {error("A '{' is expected after Exit.", false);}
}

Transitions
{
    // A '}' is the end of the transitions.
    // Look for the next state.
    RIGHT_BRACE(token : SmcLexer.Token)
                    States              {addState();}

    // This is the transition name.
    WORD(token : SmcLexer.Token)
                    TransStart          {storeTransitionName(token);}

    Default         TransError          {error("Expecting either a new transition or a '}'.", false);}
}

TransError
{
    RIGHT_BRACE(token : SmcLexer.Token)
                    States              {addState();}
    WORD(token : SmcLexer.Token)
                    TransStart          {storeTransitionName(token);}

    Default         nil                 {}
}

TransStart
{
    // A '(' means this transition has parameters.
    LEFT_PAREN(token : SmcLexer.Token)
                    TransParams         {createParameterList();}

    // A '[' denotes a guard.
    LEFT_BRACKET(token : SmcLexer.Token)
                    push(ActionMap::Start)
                                        {createTransition();}

    // The guard's condition has been found.
    action_done     GuardEnd            {}

    // Check for duplicate transitions.
    PUSH(token : SmcLexer.Token) [isDuplicateGuard();]
                    PushStart           {error("Duplicate transition - duplicate ignored.", false);
                                         createTransition();
                                         createGuard();
                                         setTransType("TRANS_PUSH");}

    POP(token : SmcLexer.Token) [isDuplicateGuard();]
                    PopStart            {error("Duplicate transition - duplicate ignored.", false);
                                         createTransition();
                                         createGuard();
                                         setTransType("TRANS_POP");}

    WORD(token : SmcLexer.Token) [isDuplicateGuard();]
                    EndState1           {error("Duplicate transition - duplicate ignored.", false);
                                         createTransition();
                                         createGuard();
                                         setTransType("TRANS_SET");
                                         setEndState(token);}

    PUSH(token : SmcLexer.Token)
                    PushStart           {createTransition();
                                         createGuard();
                                         setTransType("TRANS_PUSH");}

    POP(token : SmcLexer.Token)
                    PopStart            {createTransition();
                                         createGuard();
                                         setTransType("TRANS_POP");}

    // This word is the end state. Go to EndState1 in case this
    // is a fully qualified state name.
    WORD(token : SmcLexer.Token)
                    EndState1           {createTransition();
                                         createGuard();
                                         setTransType("TRANS_SET");
                                         setEndState(token);}

    Default         TransStartError     {error("Expecting either a guard, push, pop or end state.", false);}
}

TransStartError
{
    // A '(' means this transition has parameters.
    LEFT_PAREN(token : SmcLexer.Token)
                    TransParams         {createParameterList();}

    // A '[' means this transition is guarded.
    LEFT_BRACKET(token : SmcLexer.Token)
                    push(ActionMap::Start)
                                        {}
    action_done     GuardEnd            {}

    PUSH(token : SmcLexer.Token)
                    PushStart           {createGuard();
                                         setTransType("TRANS_PUSH");}

    POP(token : SmcLexer.Token)
                    PopStart            {createGuard();
                                         setTransType("TRANS_POP");}

    WORD(token : SmcLexer.Token)
                    EndState1           {createGuard();
                                         setTransType("TRANS_SET");
                                         setEndState(token);}

    Default         nil                 {}
}

TransNext
{
    // A parethesis means this transition has parameters.
    LEFT_PAREN(token : SmcLexer.Token)
                    TransNextError      {error("Transition parameters previously defined.", false);}

    // A bracket denotes a guard.
    LEFT_BRACKET(token : SmcLexer.Token)
                    push(ActionMap::Start)
                                        {}

    // The guard's condition has been found.
    // Create a new guard object.
    action_done     GuardEnd            {}

    // Check for duplicate transitions.
    PUSH(token : SmcLexer.Token) [isDuplicateGuard();]
                    PushStart           {error("Duplicate transition - duplicate ignored.", false);
                                         createGuard();
                                         setTransType("TRANS_PUSH");}

    POP(token : SmcLexer.Token) [isDuplicateGuard();]
                    PopStart            {error("Duplicate transition - duplicate ignored.", false);
                                         createGuard();
                                         setTransType("TRANS_POP");}

    WORD(token : SmcLexer.Token) [isDuplicateGuard();]
                    EndState1           {error("Duplicate transition - duplicate ignored.", false);
                                         createGuard();
                                         setTransType("TRANS_SET");
                                         setEndState(token);}

    PUSH(token : SmcLexer.Token)
                    PushStart           {createGuard();
                                         setTransType("TRANS_PUSH");}

    POP(token : SmcLexer.Token)
                    PopStart            {createGuard();
                                         setTransType("TRANS_POP");}

    // This word is the end state. Go to EndState1 in case this
    // is a fully qualified state name.
    WORD(token : SmcLexer.Token)
                    EndState1           {createGuard();
                                         setTransType("TRANS_SET");
                                         setEndState(token);}

    Default         TransNextError      {error("Expecting either a guard, push, pop or end state.", false);}
}

TransNextError
{
    // Transition parameters have already been defined.
    LEFT_PAREN(token : SmcLexer.Token)
                    nil                 {}

    // A bracket means this transition is guarded.
    LEFT_BRACKET(token : SmcLexer.Token)
                    push(ActionMap::Start)
                                        {}
    action_done     GuardEnd            {}

    PUSH(token : SmcLexer.Token)
                    PushStart           {createGuard();
                                         setTransType("TRANS_PUSH");}

    POP(token : SmcLexer.Token)
                    PopStart            {createGuard();
                                         setTransType("TRANS_POP");}

    WORD(token : SmcLexer.Token)
                    EndState1           {createGuard();
                                         setTransType("TRANS_SET");
                                         setEndState(token);}

    Default         nil                 {}
}

TransParams
{
    // A parethesis marks the end of the parameters. This only
    // acceptable here if the parameter list is empty. Otherwise
    // we are expecting more parameters.
    RIGHT_PAREN(token : SmcLexer.Token)
        [isTransParametersEmpty();]
                    TransNext           {createTransition();
                                         createGuard();}
    RIGHT_PAREN(token : SmcLexer.Token)
                    TransNext           {error("Expecting parameter name.", false);
                                         createTransition();
                                         createGuard();}

    WORD(token : SmcLexer.Token)
                    TransParamName      {createParameter(token);}

    Default         TransParamsError    {error("Expecting parameter name.", false);}
}

TransParamName
{
    // Parameter name must be followed by a ':'.
    COLON(token : SmcLexer.Token)
                    TransParamType      {}

    Default         TransParamsError    {error("A ':' must follow a paramater name.", false);}
}

TransParamType
{
    WORD(token : SmcLexer.Token)
                    TransParamType2     {appendParameterType(token, "");}

    // Have to see at least one type name before a ')' or a ','.
    Default         TransParamsError    {error("Expecting type name.", false);}
}

TransParamType2
{
    // A parenthesis marks the end of the parameters.
    RIGHT_PAREN(token : SmcLexer.Token)
                    TransNext           {addTransitionParameter();
                                         createTransition();}

    // A ',' marks the end of this parameter, to be followed by others.
    COMMA(token : SmcLexer.Token)
                    TransParams         {addTransitionParameter();}

    WORD(token : SmcLexer.Token)
                    TransParamType2     {appendParameterType(token, " ");}

    // Non-word symbols may be appended only to the last type.
    LEFT_BRACKET(token : SmcLexer.Token)
                    TransParamType3     {appendParameterType(token, "");}

    ASTERISK(token : SmcLexer.Token)
                    TransParamType3     {appendParameterType(token, "");}

    AMPERSAND(token : SmcLexer.Token)
                    TransParamType3     {appendParameterType(token, "");}

    Default         TransParamsError    {error("Invalid type.", false);}
}

TransParamType3
{
    // At this point, only other non-word symbols or an
    // end-of-type terminator will be accepted.
    RIGHT_PAREN(token : SmcLexer.Token)
                    TransNext           {addTransitionParameter();
                                         createTransition();}

    COMMA(token : SmcLexer.Token)
                    TransParams         {addTransitionParameter();}

    RIGHT_BRACKET(token : SmcLexer.Token)
                    nil                 {appendParameterType(token, "");}

    ASTERISK(token : SmcLexer.Token)
                    nil                 {appendParameterType(token, "");}

    AMPERSAND(token : SmcLexer.Token)
                    nil                 {appendParameterType(token, "");}

    Default         TransParamsError    {error("Invalid type.", false);}
}

TransParamsError
{
    RIGHT_PAREN(token : SmcLexer.Token)
                    TransNext           {addTransitionParameter();
                                         createTransition();}

    LEFT_BRACKET(token : SmcLexer.Token)
                    push(ActionMap::Start)
                                        {addTransitionParameter();}
    action_done     GuardEnd            {}

    Default         nil                 {}
}

GuardEnd
{
    // A backet denotes the end of the guard condition.
    RIGHT_BRACKET(token : SmcLexer.Token)
                    EndState            {}

    Default         GuardEndError       {error("A ']' must terminate a transition guard", false);}
}

GuardEndError
{
    RIGHT_BRACKET(token : SmcLexer.Token)
                    EndState            {}

    Default         nil                 {}
}

EndState
{
    // Check for a duplicate guard.
    PUSH(token : SmcLexer.Token) [isDuplicateGuard();]
                    PushStart           {error("Duplicate transition - duplicate ignored.", false);
                                         createGuard();
                                         setTransType("TRANS_PUSH");}

    POP(token : SmcLexer.Token) [isDuplicateGuard();]
                    PopStart            {error("Duplicate transition - duplicate ignored.", false);
                                         createGuard();
                                         setTransType("TRANS_POP");}

    WORD(token : SmcLexer.Token) [isDuplicateGuard();]
                    EndState1           {error("Duplicate transition - duplicate ignored.", false);
                                         createGuard();
                                         setTransType("TRANS_SET");
                                         setEndState(token);}

    PUSH(token : SmcLexer.Token)
                    PushStart           {createGuard();
                                         setTransType("TRANS_PUSH");}

    POP(token : SmcLexer.Token)
                    PopStart            {createGuard();
                                         setTransType("TRANS_POP");}

    WORD(token : SmcLexer.Token)
                    EndState1           {createGuard();
                                         setTransType("TRANS_SET");
                                         setEndState(token);}

    Default         EndStateError       {error("Expecting either \"push\", \"pop\" or end state.", false);}
}

EndStateError
{
    LEFT_BRACE(token : SmcLexer.Token)
                    push(ActionMap::MultiStart)
                                        {}
    action_done     push(ActionMap::MultiStart)
                                        {addAction();}
    actions_done    Transitions         {addGuard();
                                         addTransition();}

    RIGHT_BRACE(token : SmcLexer.Token)
                    Transitions         {addGuard();
                                         addTransition();}

    Default         nil                 {}
}

EndState1
{
    // This must be a fully qualified state name.
    COLON(token : SmcLexer.Token)
                    EndState2           {appendEndState(token);}

    // A brace denotes the start of the actions.
    LEFT_BRACE(token : SmcLexer.Token)
                    push(ActionMap::MultiStart)
                                        {}

    // There are still more actions to parse. Add this action to
    // the in-progress guard's list.
    action_done     push(ActionMap::MultiStart)
                                        {addAction();}

    // All actions have been parsed. Go on to the next transition.
    actions_done    Transitions         {addGuard();
                                         addTransition();}

    Default         EndStateError       {error("Expecting a '{'.", false);}
}

EndState2
{
    COLON(token : SmcLexer.Token)
                    EndState3           {appendEndState(token);}

    Default         EndStateError       {error("Expecting another ':' (as in map::state).", false);}
}

EndState3
{
    WORD(token : SmcLexer.Token)
                    ActionStart         {appendEndState(token);}

    Default         EndStateError       {error("Expecting a state name (as in map::state)", false);}
}

PushStart
{
    LEFT_PAREN(token : SmcLexer.Token)
                    PushMap             {}

    Default         PushError           {error("push must be followed by a '('.", false);}
}

PushError
{
    RIGHT_PAREN(token : SmcLexer.Token)
                    ActionStart         {}
    LEFT_BRACE(token : SmcLexer.Token)
                    push(ActionMap::MultiStart)
                                        {}
    action_done     push(ActionMap::MultiStart)
                                        {addAction();}
    actions_done    Transitions         {addGuard();
                                         addTransition();}

    RIGHT_BRACE(token : SmcLexer.Token)
                    Transitions         {addGuard();
                                         addTransition();}

    Default         nil                 {}
}

PushMap
{
    // Is this a map name or a state name?
    WORD(token : SmcLexer.Token)
                    PushState1          {setEndState(token);}

    Default         PushError           {error("Expecting a state name.", false);}
}

PushState1
{
    // Just the state name was provided.
    RIGHT_PAREN(token : SmcLexer.Token)
                    ActionStart         {}

    // We have seen the map name. Now we are looking for the state.
    COLON(token : SmcLexer.Token)
                    PushState2          {appendEndState(token);}

    Default         PushError           {error("Expecting either ')' or ':' (as in map::state).", false);}
}

PushState2
{
    COLON(token : SmcLexer.Token)
                    PushState3          {appendEndState(token);}

    Default         PushError           {error("Expecting ':' (as in map::state).", false);}
}

PushState3
{
    WORD(token : SmcLexer.Token)
                    PushEnd             {appendEndState(token);}

    Default         PushError           {error("Expecting a state name (as in map::state).", false);}
}

PushEnd
{
    RIGHT_PAREN(token : SmcLexer.Token)
                    ActionStart         {}

    Default         PushError           {error("push transition must end in ')' (push(state)).", false);}
}

PopStart
{
    LEFT_PAREN(token : SmcLexer.Token)
                    PopAction           {}

    // A brace denotes the start of the actions.
    // It is acceptable not to provide a pop transition.
    LEFT_BRACE(token : SmcLexer.Token)
                    push(ActionMap::MultiStart)
                                        {}
    action_done     push(ActionMap::MultiStart)
                                        {addAction();}
    actions_done    Transitions         {addGuard();
                                         addTransition();}

    Default         PopError            {error("Expecting '(trans)' or '{' after pop.", false);}
}

PopError
{
    RIGHT_PAREN(token : SmcLexer.Token)
                    ActionStart         {}

    LEFT_BRACE(token : SmcLexer.Token)
                    push(ActionMap::MultiStart)
                                        {}
    action_done     push(ActionMap::MultiStart)
                                        {addAction();}
    actions_done    Transitions         {addGuard();
                                         addTransition();}

    RIGHT_BRACE(token : SmcLexer.Token)
                    Transitions         {addGuard();
                                         addTransition();}

    Default         nil                 {}
}

PopAction
{
    RIGHT_PAREN(token : SmcLexer.Token)
                    ActionStart         {}

    WORD(token : SmcLexer.Token)
                    PopArgs             {setEndState(token);}

    Default         PopError            {error("Expecting either a pop transition or ')'.", false);}
}

PopArgs
{
    // No more pop arguments. Start collecting the actions.
    RIGHT_PAREN(token : SmcLexer.Token)
                    ActionStart         {}

    // A comma signifies there are more arguments
    // in this transition.
    COMMA(token : SmcLexer.Token)
                    push(ArgMap::ArgsStart)
                                        {}
    ArgsDone(argList : List)
                    ActionStart         {setPopArgs(argList);}

    ArgsError       ActionStart         {}

    Default         PopError            {error("Expecting ')' to end the pop transition.", false);}
}

ActionStart
{
    // A brace denotes the start of the actions.
    LEFT_BRACE(token : SmcLexer.Token)
                    push(ActionMap::MultiStart)
                                        {}

    // There are still more actions to parse. Add this action to
    // the in-progress guard's list.
    action_done     push(ActionMap::MultiStart)
                                        {addAction();}

    // All actions have been parsed. Go on to the next transition.
    actions_done    Transitions         {addGuard();
                                         addTransition();}

    Default         ActionStartError    {error("A '{' must proceed any action definitions.", false);}
}

ActionStartError
{
    LEFT_BRACE(token : SmcLexer.Token)
                    push(ActionMap::MultiStart)
                                        {}
    action_done     push(ActionMap::MultiStart)
                                        {addAction();}
    actions_done    Transitions         {addGuard();
                                         addTransition();}

    RIGHT_BRACE(token : SmcLexer.Token)
                    Transitions         {addGuard();
                                         addTransition();}

    Default         nil                 {}
}

%%

//===============================================================
// ActionMap
// This map is used to parse a single action. Actions are of the
// form:
// WORD '(' {args} ')' ';'
//
%map ActionMap
%%

// Start here if you are looking for muliple actions.
MultiStart
{
    RIGHT_BRACE(token : SmcLexer.Token)
                    pop(actions_done)   {}

    // This word is the action name.
    WORD(token : SmcLexer.Token)
                    ArgsStart           {createAction(token);}

    Default         ActionStartError    {error("Expecting either a new action or a '}'.", false);}
}

// Start here if you are looking for a single action.
Start
{
    // This word is the action name.
    WORD(token : SmcLexer.Token)
                    ArgsStart           {createAction(token);}

    // A "!" means that this action is being negated.
    // Probably being used as a guard.
    EXCLAMATION(token : SmcLexer.Token)
                    nil                 {setActionNegation();}

    Default         ActionStartError    {error("Expecting action name.", false);}
}

ActionStartError
{
    WORD(token : SmcLexer.Token)
                    ArgsStart           {createAction(token);}

    EXCLAMATION(token : SmcLexer.Token)
                    Start               {createAction(token);
                                         setActionNegation();}

    LEFT_PAREN(token : SmcLexer.Token)
                    ArgsStart           {createAction(token);}

    RIGHT_PAREN(token : SmcLexer.Token)
                    ArgsEnd             {}

    SEMICOLON(token : SmcLexer.Token)
                    pop(action_done)    {}

    RIGHT_BRACE(token : SmcLexer.Token)
                    pop(actions_done)   {}

    Default         nil                 {}
}

ArgsStart
{
    LEFT_PAREN(token : SmcLexer.Token)
                    push(ArgMap::ArgsStart)
                                        {}
    ArgsDone(argList : List)
                    ArgsEnd             {setActionArgs(argList);}

    ArgsError       ArgsEndError        {}

    // Error transitions.
    RIGHT_PAREN(token : SmcLexer.Token)
                    ArgsEnd             {error("Expecting '(' after the action name.", false);}
    SEMICOLON(token : SmcLexer.Token)
                    pop(action_done)    {error("Expecting '(' after the action name.", false);}
    RIGHT_BRACE(token : SmcLexer.Token)
                    pop(actions_done)   {error("Expecting '(' after the action name.", false);}

    Default         ArgsStartError      {error("Expecting '(' after the action name.", false);}
}

ArgsStartError
{
    LEFT_PAREN(token : SmcLexer.Token)
                    push(ArgMap::ArgsStart)
                                        {}
    ArgsDone(argList : List)
                    ArgsEnd             {setActionArgs(argList);}
    ArgsError       ArgsEndError        {}

    RIGHT_PAREN(token : SmcLexer.Token)
                    ArgsEnd             {}
    SEMICOLON(token : SmcLexer.Token)
                    pop(action_done)    {}

    Default         nil                 {}
}

ArgsEnd
{
    SEMICOLON(token : SmcLexer.Token)
                    pop(action_done)    {}

    Default         ArgsEndError        {error("Actions must be terminated with a ';'.", false);}
}

ArgsEndError
{
    SEMICOLON(token : SmcLexer.Token)
                    pop(action_done)    {}

    Default         nil                 {}
}

%%

//===============================================================
// Argument Map
// This map is used to collect action and pop arguments.
//
%map ArgMap
%%
ArgsStart
Entry {pushArgStack();}
{
    // Look for scoped variable names.
    WORD(token : SmcLexer.Token)
                    VarArg1             {createVariable(token);}

    VARIABLE(token : SmcLexer.Token)
                    NextArgument        {addSimpleArgument(token);}
    INTEGER(token : SmcLexer.Token)
                    NextArgument        {addSimpleArgument(token);}
    FLOAT(token : SmcLexer.Token)
                    NextArgument        {addSimpleArgument(token);}
    STRING(token : SmcLexer.Token)
                    NextArgument        {addSimpleArgument(token);}

    // There are no arguments.
    RIGHT_PAREN(token : SmcLexer.Token)
                    pop(ArgsDone, ctxt.getArgsResult())
                                        {setArgsResult();
										 popArgStack();}

    Default         ArgsError           {error("Expecting either a valid argument or a ')'.", false);}
}

ArgsContinue
{
    // Look for scoped variable names.
    WORD(token : SmcLexer.Token)
                    VarArg1             {createVariable(token);}

    VARIABLE(token : SmcLexer.Token)
                    NextArgument        {addSimpleArgument(token);}
    INTEGER(token : SmcLexer.Token)
                    NextArgument        {addSimpleArgument(token);}
    FLOAT(token : SmcLexer.Token)
                    NextArgument        {addSimpleArgument(token);}
    STRING(token : SmcLexer.Token)
                    NextArgument        {addSimpleArgument(token);}

    // There are no arguments.
    RIGHT_PAREN(token : SmcLexer.Token)
                    pop(ArgsDone, ctxt.getArgsResult())
                                        {setArgsResult();
										 popArgStack();}

    Default         ArgsError           {error("Expecting either a valid argument or a ')'.", false);}
}

VarArg1
{
    // A colon means that this argument is scoped.
    // (Identifiers using the period scope are handled in the
    //  lexer.)
    COLON(token : SmcLexer.Token)
                    VarArg2             {appendVariable(token);}

    // End of arguments.
    RIGHT_PAREN(token : SmcLexer.Token)
                    pop(ArgsDone, ctxt.getArgsResult())
										{addVariableArgument();
										 setArgsResult();
										 popArgStack();}

    // A left paren denotes that this identifier is a function
	// call. 
    LEFT_PAREN(token : SmcLexer.Token)
                    push(ArgsStart)		{}
    ArgsDone(argList : List)
					NextArgument		{addMethodArgument(argList);}
	ArgsError		ArgsError			{}

    // A new argument.
    COMMA(token : SmcLexer.Token)
                    ArgsContinue        {addVariableArgument();}

    Default         ArgsError           {error("Expecting either ',' or ')'.", false);}
}

VarArg2
{
    COLON(token : SmcLexer.Token)
                    VarArgEnd           {appendVariable(token);}

    Default         ArgsError           {error("Expecting ':' after first ':'.", false);}
}

VarArgEnd
{
    // Handle multiply scoped variables.
    WORD(token : SmcLexer.Token)
                    VarArg1             {appendVariable(token);}
}

NextArgument
{
    RIGHT_PAREN(token : SmcLexer.Token)
                    pop(ArgsDone, ctxt.getArgsResult())
										{setArgsResult();
										 popArgStack();}

    COMMA(token : SmcLexer.Token)
                    ArgsContinue        {}

    Default         ArgsError           {error("Expecting either ',' or ')'.", false);}
}

ArgsError
{
    RIGHT_PAREN(token : SmcLexer.Token)
                    pop(ArgsError)      {popArgStack();}

    Default         nil                 {}
}

%%

//===============================================================
// Name Map
// This map parses fully qualified class names.
//
%map NameMap
%%
// Get the owning object's class name.
FQName
{
    // The next token must be the class name. The class name may
    // begin with a colon.
    COLON(token : SmcLexer.Token)
                Colon1          {appendClassName(token);}
    WORD(token : SmcLexer.Token)
                ClassName       {appendClassName(token);}

    Default     pop(FQNameError)
                                {error("Missing class name after %keyword.", false);}
}

ClassName
{
    // If there is a ':', then this is a FQ name.
    COLON(token : SmcLexer.Token)
                    Colon1              {appendClassName(token);}

    // Look for a '%' keyword to mark the end of the class name.
    START_STATE(token : SmcLexer.Token)
                    pop(FQNameDone, ctxt.getFQName())
										{pushBack(token);}

    HEADER_FILE(token : SmcLexer.Token)
                    pop(FQNameDone, ctxt.getFQName())
										{pushBack(token);}

    PACKAGE_NAME(token : SmcLexer.Token)
                    pop(FQNameDone, ctxt.getFQName())
										{pushBack(token);}

    IMPORT(token : SmcLexer.Token)
                    pop(FQNameDone, ctxt.getFQName())
										{pushBack(token);}

    MAP_NAME(token : SmcLexer.Token)
                    pop(FQNameDone, ctxt.getFQName())
										{pushBack(token);}

    Default         nil                 {error("Expecting \"%start\", \"%header\", \"%package\" or \"%map\".", false);}
}

// Each part of the class name is separated by two (or more)
// colons.
Colon1
{
    COLON(token : SmcLexer.Token)
                    Colon2              {appendClassName(token);}

    // Anything else is an error.
    Default         nil                 {error("Expecting \"::\" in fully qualified class name.", false);}
}

// A word *may* follow the two colons.
Colon2
{
    WORD(token : SmcLexer.Token)
                    ClassName           {appendClassName(token);}

    // Ignore excess colons.
    COLON(token : SmcLexer.Token)
                    nil                 {}

    Default         nil                 {error("Expecting a string after \"::\" in fully qualified class name.", false);}
}

%%
