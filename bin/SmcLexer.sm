// -*- mode: text; tab-width: 4; mode: auto-fill; -*-
%{
/*
 * The contents of this file are subject to the Mozilla Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.mozilla.org/MPL/
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is State Map Compiler (SMC).
 * 
 * The Initial Developer of the Original Code is Charles W. Rapp.
 * Portions created by Charles W. Rapp are
 * Copyright (C) 2000 Charles W. Rapp.
 * All Rights Reserved.
 * 
 * Contributor(s): 
 *
 * smcLexer --
 *
 *  This statemap finds tokens in a statemap source file.
 *
 * RCS ID
 * $Id$
 *
 * CHANGE LOG
 * $Log$
 * Revision 1.1  2001/01/03 03:13:59  cwrapp
 * Initial revision
 *
 * Revision 1.2  2000/09/01 15:32:11  charlesr
 * Changes for v. 1.0, Beta 2:
 *
 * + Removed order dependency on "%start", "%class" and "%header"
 *   appearance. These three tokens may now appear in any order but
 *   still must appear before the first map definition.
 *
 * + Modified SMC parser so that it will continue after finding an
 *   error. Also improved the error message quality.
 *
 * + Made error messages so emacs is able to parse them.
 *
 * Revision 1.1.1.1  2000/08/02 12:50:56  charlesr
 * Initial source import, SMC v. 1.0, Beta 1.
 *
 */
%}

%start TokenMap::Start
%class SmcLexer

%map TokenMap
%%

//-----------------+---------------+-------------------+-------------+
//      Start      |               |        End        |             |
//      State      |   Transition  |       State       |   Actions   |
//-----------------+---------------+-------------------+-------------+
Start
{
	// Is this the start of a comment?
	slash			CommentStart		{}

	// Multi-character tokens.
	percent			PercentStart		{startToken();
										 addCurrentCharToToken();}
	alpha			Word				{startToken();
										 addCurrentCharToToken();}
	underscore		Word				{startToken();
										 addCurrentCharToToken();}
	dollarsign		Variable			{startToken();
										 addCurrentCharToToken();}
	digit			Number				{startToken();
										 addCurrentCharToToken();}
	dash			Number				{startToken();
										 addCurrentCharToToken();}
	doublequote		String				{startToken();
										 addCurrentCharToToken();}

	// Single character tokens.
	left_brace		nil					{startToken();
										 addCurrentCharToToken();
										 endToken(SmcLexer.LEFT_BRACE);}
	right_brace		nil					{startToken();
										 addCurrentCharToToken();
										 endToken(SmcLexer.RIGHT_BRACE);}
	left_bracket	nil					{startToken();
										 addCurrentCharToToken();
										 endToken(SmcLexer.LEFT_BRACKET);}
	right_bracket	nil					{startToken();
										 addCurrentCharToToken();
										 endToken(SmcLexer.RIGHT_BRACKET);}
	left_paren		nil					{startToken();
										 addCurrentCharToToken();
										 endToken(SmcLexer.LEFT_PAREN);}
	right_paren		nil					{startToken();
										 addCurrentCharToToken();
										 endToken(SmcLexer.RIGHT_PAREN);}
	semicolon		nil					{startToken();
										 addCurrentCharToToken();
										 endToken(SmcLexer.SEMICOLON);}
	colon			nil					{startToken();
										 addCurrentCharToToken();
										 endToken(SmcLexer.COLON);}
	comma			nil					{startToken();
										 addCurrentCharToToken();
										 endToken(SmcLexer.COMMA);}
	exclamation		nil					{startToken();
										 addCurrentCharToToken();
										 endToken(SmcLexer.EXCLAMATION);}
	asterisk		CommentEnd			{startToken();
										 addCurrentCharToToken();}
	ampersand		nil       			{startToken();
										 addCurrentCharToToken();
                                         endToken(SmcLexer.AMPERSAND);}

	// Ignore whitespace and end-of-line.
	whitespace		nil					{}
	EOL				nil					{}

	unknown			nil					{addCurrentCharToToken();
									     badToken("Unknown character");}
}

CommentStart
{
	asterisk		push(OldCommentMap::Start)	{}
	slash			push(NewCommentMap::Start)	{}
	commentDone		Start				{}

	// Any other character following a slash is a malformed token.
	Default		    Start			    {addCurrentCharToToken();
										 badToken("Unknown token");}
}

CommentEnd
{
	slash			Start				{addCurrentCharToToken();
										 badToken("End-of-comment appears without matching start-of-comment");}

    asterisk        nil                 {endToken(SmcLexer.ASTERISK);
                                         startToken();
                                         addCurrentCharToToken();}

    Default         Start               {ungetChar();
                                         endToken(SmcLexer.ASTERISK);}
}

PercentStart
{
	// This the start of a source code.
	left_brace		push(SourceMap::Start)	{startToken();}
	sourceDone		Start				{}

	// This is the map delimiter.
	percent			Start				{addCurrentCharToToken();
										 endToken(SmcLexer.EOD);}

	// Look for %start, %map, %class or %header.
	alpha			Map					{addCurrentCharToToken();}

	// Any other character following a percent is a malformed token.
	right_brace		Start				{addCurrentCharToToken();
										 badToken("End-of-source appears without matching start-of-source");}

	Default		    Start			    {addCurrentCharToToken();
										 badToken("Unknown % directive");}
}

Map
{
	// Keep collecting characters until whitespace or EOL is reached.
	whitespace		Start				{checkPercentKeyword();}
	EOL				Start				{checkPercentKeyword();}

	// Only letters are allowed after the percent.
	alpha			nil					{addCurrentCharToToken();}

	// Anything else is a bad token.
	Default		    Start				{addCurrentCharToToken();
										 badToken("Unknown % directive");}
}

Word
{
	alpha			nil					{addCurrentCharToToken();}
	digit			nil					{addCurrentCharToToken();}
	underscore		nil					{addCurrentCharToToken();}
	period			nil					{addCurrentCharToToken();}

	whitespace		Start				{checkKeyword();}
	EOL				Start				{checkKeyword();}

	// All other characters are a part of other tokens. "Unread"
	// the tokens so they can be read the next call to nextToken()
	// and then pass this token back.
	left_brace		Start				{ungetChar();
										 checkKeyword();}
	right_brace		Start				{ungetChar();
										 checkKeyword();}
	left_bracket	Start				{ungetChar();
										 checkKeyword();}
	right_bracket	Start				{ungetChar();
										 checkKeyword();}
	left_paren		Start				{ungetChar();
										 checkKeyword();}
	right_paren		Start				{ungetChar();
										 checkKeyword();}
	semicolon		Start				{ungetChar();
										 checkKeyword();}
	colon			Start				{ungetChar();
										 checkKeyword();}
	comma			Start				{ungetChar();
										 checkKeyword();}
	exclamation		Start				{ungetChar();
										 checkKeyword();}
	doublequote		Start				{ungetChar();
										 checkKeyword();}
	slash			Start				{ungetChar();
										 checkKeyword();}
	asterisk		Start				{ungetChar();
										 checkKeyword();}
	dollarsign		Start				{ungetChar();
										 checkKeyword();}
    ampersand       Start               {ungetChar();
										 checkKeyword();}
    dash            Start               {ungetChar();
										 checkKeyword();}
    

	// The remaining characters form an invalid token.
	Default			Start				{addCurrentCharToToken();
										 badToken("Unknown token");}
}

Variable
{
	// Need to seen an alpha character before a digit can be accepted.
	alpha			Variable2			{addCurrentCharToToken();}

	// Wait here for an alpha.
	underscore		nil					{addCurrentCharToToken();}

	// Any other character represents a malformed variable.
	Default			Start				{addCurrentCharToToken();
										 badToken("Malformed variable.");}
}

Variable2
{
	alpha			nil					{addCurrentCharToToken();}
	digit			nil					{addCurrentCharToToken();}
	underscore		nil					{addCurrentCharToToken();}

	whitespace		Start				{endToken(SmcLexer.VARIABLE);}
	EOL				Start				{endToken(SmcLexer.VARIABLE);}

	Default			Start				{addCurrentCharToToken();
										 badToken("Malformed variable.");}
}

Number
{
	digit			nil					{addCurrentCharToToken();}

	// This must be a float number instead of an integer.
	period			FloatNumber			{addCurrentCharToToken();}

	whitespace		Start				{endToken(SmcLexer.INTEGER);}
	EOL				Start				{endToken(SmcLexer.INTEGER);}

	// All other characters are a part of other tokens. "Unread"
	// the tokens so they can be read the next call to nextToken()
	// and then pass this token back.
	left_brace		Start				{ungetChar();
										 endToken(SmcLexer.INTEGER);}
	right_brace		Start				{ungetChar();
										 endToken(SmcLexer.INTEGER);}
	left_bracket	Start				{ungetChar();
										 endToken(SmcLexer.INTEGER);}
	right_bracket	Start				{ungetChar();
										 endToken(SmcLexer.INTEGER);}
	left_paren		Start				{ungetChar();
										 endToken(SmcLexer.INTEGER);}
	right_paren		Start				{ungetChar();
										 endToken(SmcLexer.INTEGER);}
	semicolon		Start				{ungetChar();
										 endToken(SmcLexer.INTEGER);}
	colon			Start				{ungetChar();
										 endToken(SmcLexer.INTEGER);}
	comma			Start				{ungetChar();
										 endToken(SmcLexer.INTEGER);}
	exclamation		Start				{ungetChar();
										 endToken(SmcLexer.INTEGER);}
	doublequote		Start				{ungetChar();
										 endToken(SmcLexer.INTEGER);}
	slash			Start				{ungetChar();
										 endToken(SmcLexer.INTEGER);}
	asterisk		Start				{ungetChar();
										 endToken(SmcLexer.INTEGER);}
	dollarsign		Start				{ungetChar();
										 endToken(SmcLexer.INTEGER);}

	// The remaining characters form an invalid token.
	Default			Start				{addCurrentCharToToken();
										 badToken("Unknown token");}
}

FloatNumber
{
	digit			nil					{addCurrentCharToToken();}

	whitespace		Start				{endToken(SmcLexer.FLOAT);}
	EOL				Start				{endToken(SmcLexer.FLOAT);}

	// All other characters are a part of other tokens. "Unread"
	// the tokens so they can be read the next call to nextToken()
	// and then pass this token back.
	left_brace		Start				{ungetChar();
										 endToken(SmcLexer.FLOAT);}
	right_brace		Start				{ungetChar();
										 endToken(SmcLexer.FLOAT);}
	left_bracket	Start				{ungetChar();
										 endToken(SmcLexer.FLOAT);}
	right_bracket	Start				{ungetChar();
										 endToken(SmcLexer.FLOAT);}
	left_paren		Start				{ungetChar();
										 endToken(SmcLexer.FLOAT);}
	right_paren		Start				{ungetChar();
										 endToken(SmcLexer.FLOAT);}
	semicolon		Start				{ungetChar();
										 endToken(SmcLexer.FLOAT);}
	colon			Start				{ungetChar();
										 endToken(SmcLexer.FLOAT);}
	comma			Start				{ungetChar();
										 endToken(SmcLexer.FLOAT);}
	exclamation		Start				{ungetChar();
										 endToken(SmcLexer.FLOAT);}
	doublequote		Start				{ungetChar();
										 endToken(SmcLexer.FLOAT);}
	slash			Start				{ungetChar();
										 endToken(SmcLexer.FLOAT);}
	asterisk		Start				{ungetChar();
										 endToken(SmcLexer.FLOAT);}
	dollarsign		Start				{ungetChar();
										 endToken(SmcLexer.FLOAT);}

	// The remaining characters form an invalid token.
	Default			Start				{addCurrentCharToToken();
										 badToken("Unknown token");}
}

String
{
	// Look for the double quote to end this string.
	doublequote		Start				{addCurrentCharToToken();
										 endToken(SmcLexer.STRING);}

	// A backslash escapes the next character.
	backslash	    Escape				{addCurrentCharToToken();}

	// An end-of-line before the end of the string is wrong.
	EOL				Start				{badToken("String contains a new line.");}

	// Any other character is simply added to the string.
	Default		    nil					{addCurrentCharToToken();}
}

Escape
{
	// Whatever this character is, add it to the string.
	Default			String				{addCurrentCharToToken();}
}

Default
{
	// Backslashes can only appear in strings.
	backslash	   nil				   {badToken("Backslash can only be used in strings.");}
}

%%

%map OldCommentMap
%%

Start
{
	slash			CommentStart		{}
	asterisk		CommentEnd			{}
}

CommentStart
{
	asterisk		push(OldCommentMap::Start)	{}
	slash			push(NewCommentMap::Start)	{}
	commentDone		Start				{}
}

CommentEnd
{
	asterisk		nil					{}
	slash			pop(commentDone)	{}
}

Default
{
	alpha			Start				{}
	digit			Start				{}
	percent			Start				{}
	slash			Start				{}
	backslash		Start				{}
	asterisk		Start				{}
	left_brace		Start				{}
	right_brace		Start				{}
	left_bracket	Start				{}
	right_bracket	Start				{}
	left_paren		Start				{}
	right_paren		Start				{}
	period			Start				{}
	semicolon		Start				{}
	colon			Start				{}
	comma			Start				{}
	exclamation		Start				{}
	underscore		Start				{}
	dollarsign		Start				{}
	doublequote		Start				{}
	whitespace		Start				{}
	EOL				Start				{}
    dash            Start               {}
	unknown			Start				{}
}

%%

%map NewCommentMap
%%

// Wait here for the end of the // comment.
Start
{
	// The end of line marks the end of the comment.
	EOL				pop(commentDone)	{}
}

Default
{
	alpha			Start				{}
	digit			Start				{}
	percent			Start				{}
	slash			Start				{}
	backslash		Start				{}
	asterisk		Start				{}
	left_brace		Start				{}
	right_brace		Start				{}
	left_bracket	Start				{}
	right_bracket	Start				{}
	left_paren		Start				{}
	right_paren		Start				{}
	period			Start				{}
	semicolon		Start				{}
	colon			Start				{}
	comma			Start				{}
	exclamation		Start				{}
	underscore		Start				{}
	dollarsign		Start				{}
	doublequote		Start				{}
	whitespace		Start				{}
    dash            Start               {}
	unknown			Start				{}
}

%%

%map SourceMap
%%

// Look for the end of the source block.
Start
{
	// Is this the end of the raw source code?
	percent			SourceEnd			{}

	// No, the end has not come.
	Default		    Start				{addCurrentCharToToken();}
}

SourceEnd
{
	// Yes, we are add the end of the raw source code.
	right_brace		pop(sourceDone)		{endToken(SmcLexer.SOURCE);}

	// Perhaps this is the end of the raw source.
	percent			nil					{addCharToToken("%");}

	// Nope, this is not the end of the raw source.
	Default		    Start				{addCharToToken("%");
										 addCurrentCharToToken();}
}

// This state is never used. It is here to force smc to generate all the
// necessary default transitions.
NeverUsed
{

	alpha			nil					{}
	digit			nil					{}
	slash			nil					{}
	backslash		nil					{}
	asterisk		nil					{}
    ampersand       nil                 {}
	left_brace		nil					{}
	right_brace		nil					{}
	left_bracket	nil					{}
	right_bracket	nil					{}
	left_paren		nil					{}
	right_paren		nil					{}
	period			nil					{}
	semicolon		nil					{}
	colon			nil					{}
	comma			nil					{}
	exclamation		nil					{}
	underscore		nil					{}
	dollarsign		nil					{}
	doublequote		nil					{}
	whitespace		nil					{}
    dash            nil                 {}
	unknown			nil					{}
	EOL				nil					{}
}

%%
